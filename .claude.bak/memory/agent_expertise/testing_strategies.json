{
  "tdd_practices": [
    {
      "phase": "Red",
      "description": "Write failing test first",
      "guidelines": [
        "Test one behavior at a time",
        "Use descriptive test names that explain business requirements",
        "Start with the simplest failing test"
      ],
      "anti_patterns": ["Testing implementation details", "Overly complex first tests"]
    },
    {
      "phase": "Green", 
      "description": "Make test pass with minimal code",
      "guidelines": [
        "Write just enough code to pass the test",
        "Resist urge to write 'perfect' code immediately",
        "Focus on making it work, not making it beautiful"
      ],
      "anti_patterns": ["Over-engineering", "Adding untested functionality"]
    },
    {
      "phase": "Refactor",
      "description": "Improve design while keeping tests green",
      "guidelines": [
        "Extract common patterns",
        "Improve naming and structure",
        "Ensure all tests still pass"
      ],
      "anti_patterns": ["Changing behavior", "Refactoring without tests"]
    }
  ],
  "testing_patterns": [
    {
      "pattern": "Property-Based Testing",
      "description": "Generate test cases to verify invariants",
      "rust_example": "#[quickcheck] fn prop_email_roundtrip(email: ValidEmail) -> bool",
      "benefits": ["Finds edge cases", "Documents invariants", "Higher confidence"]
    },
    {
      "pattern": "Characterization Tests",
      "description": "Capture existing behavior before refactoring",
      "use_case": "Legacy code without tests",
      "benefits": ["Safety net for refactoring", "Understanding existing behavior"]
    },
    {
      "pattern": "Test Doubles",
      "description": "Replace dependencies for isolated testing",
      "types": ["Mocks", "Stubs", "Fakes"],
      "guidelines": ["Use sparingly", "Prefer real objects when possible"]
    }
  ],
  "rust_testing_specifics": [
    {
      "feature": "Unit Tests",
      "location": "Same file as code under test",
      "convention": "#[cfg(test)] mod tests",
      "benefits": ["Close to implementation", "Easy to maintain"]
    },
    {
      "feature": "Integration Tests", 
      "location": "tests/ directory",
      "purpose": "Test public API from external perspective", 
      "benefits": ["User perspective", "API validation"]
    },
    {
      "feature": "Doc Tests",
      "location": "In documentation comments",
      "purpose": "Ensure examples in docs actually work",
      "benefits": ["Living documentation", "Example validation"]
    }
  ],
  "test_architecture_guidelines": [
    {
      "principle": "Test Behavior, Not Implementation",
      "description": "Focus on what the code does, not how it does it",
      "example": "Test that user is authenticated, not that token is validated"
    },
    {
      "principle": "Arrange-Act-Assert",
      "description": "Clear test structure",
      "sections": ["Setup test data", "Execute behavior", "Verify results"]
    },
    {
      "principle": "Independent Tests",
      "description": "Each test should be able to run in isolation",
      "requirements": ["No shared state", "Deterministic", "Fast execution"]
    }
  ]
}