name: Security Monitoring

# Comprehensive security monitoring workflow for dependency, code, and configuration scanning
# Runs daily automated scans and on changes to security-related files

on:
  schedule:
    # Run daily security checks at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of security scan to run'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - dependencies
          - code
  push:
    branches: [ "main" ]
    paths:
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'deny.toml'
      - '.github/workflows/security-monitoring.yml'
  pull_request:
    branches: [ "main" ]
    paths:
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'deny.toml'
      - '.github/workflows/security-monitoring.yml'

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: 1

# Global environment variables for consistent security scanning behavior

permissions:
  contents: read
  security-events: write
  actions: read
  issues: write

# Required permissions for security scanning and issue creation

jobs:
  # ============================================================================
  # DEPENDENCY SECURITY SCANNING
  # ============================================================================
  dependency-audit:
    name: Daily Dependency Audit
    runs-on: ubuntu-latest
    # Run for full scans, dependency-only scans, or scheduled daily runs
    if: github.event.inputs.scan_type == 'full' || github.event.inputs.scan_type == 'dependencies' || github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Install security tools
        run: |
          # Install security auditing tools with locked versions for reproducibility
          cargo install --locked cargo-audit cargo-deny

          echo "Tool versions:"
          cargo audit --version
          cargo deny --version

      - name: Run comprehensive security audit
        run: |
          echo "::group::Vulnerability Audit"
          set +e  # Don't exit on error immediately to allow proper error handling

          # Run audit and capture exit code
          cargo audit --json > audit-report.json
          AUDIT_EXIT_CODE=$?

          # Ensure valid JSON output even on error
          if [ ! -s audit-report.json ] || ! jq empty audit-report.json 2>/dev/null; then
            echo '{"vulnerabilities": [], "warnings": []}' > audit-report.json
          fi

          # Check if vulnerabilities found
          VULN_COUNT=$(jq '.vulnerabilities | length' audit-report.json 2>/dev/null || echo 0)
          WARNING_COUNT=$(jq '.warnings | length' audit-report.json 2>/dev/null || echo 0)

          echo "Vulnerabilities found: $VULN_COUNT"
          echo "Warnings found: $WARNING_COUNT"

          if [ "$VULN_COUNT" -gt 0 ]; then
            echo "::error::$VULN_COUNT vulnerabilities found"
            jq -r '.vulnerabilities[] | "ID: \(.id), Package: \(.package.name), Severity: \(.advisory.severity // "unknown")"' audit-report.json
            exit 1
          elif [ "$WARNING_COUNT" -gt 0 ]; then
            echo "::warning::$WARNING_COUNT warnings found"
            jq -r '.warnings[] | "Kind: \(.kind), Message: \(.message)"' audit-report.json
          else
            echo "::notice::No vulnerabilities or warnings found"
          fi
          echo "::endgroup::"

          # Exit with original audit exit code if there were vulnerabilities
          if [ "$VULN_COUNT" -gt 0 ]; then
            exit $AUDIT_EXIT_CODE
          fi

      - name: Run cargo-deny check
        run: |
          echo "::group::Cargo Deny Check"
          # Run cargo deny check with proper exit code handling
          set +e  # Don't exit on error immediately
          cargo deny check --format json > deny-results.json
          DENY_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          # Only suppress policy violation errors (exit code 1)
          # Fail on tool/configuration errors (other exit codes)
          if [ $DENY_EXIT_CODE -ne 0 ] && [ $DENY_EXIT_CODE -ne 1 ]; then
            echo "::error::cargo deny tool failed with exit code $DENY_EXIT_CODE"
            echo "::error::This indicates a configuration or tool error, not policy violations"
            exit $DENY_EXIT_CODE
          fi

          # Enhanced error reporting while maintaining test compatibility
          if [ -s deny-results.json ]; then
            # Check for errors in different categories
            LICENSE_ERRORS=$(jq '.errors[]? | select(.type == "license") | length' deny-results.json 2>/dev/null || echo 0)
            ADVISORY_ERRORS=$(jq '.errors[]? | select(.type == "advisory") | length' deny-results.json 2>/dev/null || echo 0)
            BAN_ERRORS=$(jq '.errors[]? | select(.type == "ban") | length' deny-results.json 2>/dev/null || echo 0)
            SOURCE_ERRORS=$(jq '.errors[]? | select(.type == "source") | length' deny-results.json 2>/dev/null || echo 0)

            TOTAL_ERRORS=$((LICENSE_ERRORS + ADVISORY_ERRORS + BAN_ERRORS + SOURCE_ERRORS))

            if [ "$TOTAL_ERRORS" -gt 0 ]; then
              echo "::error::$TOTAL_ERRORS deny violations found"
              jq -r '.errors[]? | "\(.type | upper): \(.message)"' deny-results.json || true
              exit 1
            else
              echo "::notice::No deny violations found"
            fi
          else
            echo "::notice::No deny violations found"
          fi
          echo "::endgroup::"

      - name: Analyze dependency tree
        run: |
          echo "::group::Dependency Analysis"
          cargo tree --format "{p} {r}" > dependency-tree.txt

          # Count dependencies
          DIRECT_DEPS=$(grep -v "├─\|└─" dependency-tree.txt | wc -l)
          TOTAL_DEPS=$(wc -l < dependency-tree.txt)

          echo "Direct dependencies: $DIRECT_DEPS"
          echo "Total dependencies: $TOTAL_DEPS"

          # Check for security-sensitive dependencies
          echo "Security-sensitive dependencies:"
          grep -E "(crypto|ssl|tls|auth|rand|hash)" dependency-tree.txt || echo "None found"
          echo "::endgroup::"

      - name: Check for unsafe code
        run: |
          echo "::group::Unsafe Code Analysis"
          # Install cargo-geiger separately to avoid conflicts
          cargo install --locked cargo-geiger || echo "::warning::cargo-geiger installation failed, skipping unsafe code analysis"

          if command -v cargo-geiger &> /dev/null; then
            cargo geiger --format json > geiger-report.json || echo '{}' > geiger-report.json

            if [ -s geiger-report.json ] && [ "$(cat geiger-report.json)" != "{}" ]; then
              UNSAFE_COUNT=$(jq '.used.functions.unsafe + .used.expressions.unsafe + .used.impls.unsafe + .used.traits.unsafe + .used.methods.unsafe' geiger-report.json 2>/dev/null || echo 0)

              if [ "$UNSAFE_COUNT" -gt 0 ]; then
                echo "::warning::$UNSAFE_COUNT unsafe code blocks found"
                cargo geiger || true
              else
                echo "::notice::No unsafe code found"
              fi
            else
              echo "::warning::cargo-geiger analysis could not be completed"
            fi
          else
            echo "::warning::cargo-geiger not available, skipping unsafe code analysis"
            echo '{}' > geiger-report.json
          fi
          echo "::endgroup::"

      - name: Generate security summary
        if: always()
        run: |
          echo "::group::Security Summary"

          # Create a summary report
          cat > security-summary.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "vulnerabilities": $(jq '.vulnerabilities | length' audit-report.json 2>/dev/null || echo 0),
            "warnings": $(jq '.warnings | length' audit-report.json 2>/dev/null || echo 0),
            "deny_violations": {
              "total": $(jq '.errors | length' deny-results.json 2>/dev/null || echo 0)
            },
            "unsafe_code_blocks": $(jq '.used.functions.unsafe + .used.expressions.unsafe + .used.impls.unsafe + .used.traits.unsafe + .used.methods.unsafe' geiger-report.json 2>/dev/null || echo 0)
          }
          EOF

          echo "Security scan summary:"
          jq . security-summary.json
          echo "::endgroup::"

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports-${{ github.run_number }}
          path: |
            audit-report.json
            deny-results.json
            dependency-tree.txt
            geiger-report.json
            security-summary.json
          retention-days: 30

  # ============================================================================
  # CODE SECURITY SCANNING
  # ============================================================================

  code-security-scan:
    name: Code Security Scan
    runs-on: ubuntu-latest
    # Run for full scans, code-only scans, or scheduled daily runs
    if: github.event.inputs.scan_type == 'full' || github.event.inputs.scan_type == 'code' || github.event_name == 'schedule'
    permissions:
      contents: read
      security-events: write
      actions: read
    env:
      # Enable experimental CodeQL features for enhanced Rust analysis
      CODEQL_ENABLE_EXPERIMENTAL_FEATURES: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Initialize CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: rust
          config-file: ./.github/codeql/codeql-config.yml

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Build for CodeQL Analysis
        run: |
          # Build all workspace targets to ensure comprehensive analysis coverage
          cargo build --workspace --all-targets

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      - name: Check for security patterns
        run: |
          echo "::group::Security Pattern Analysis"

          # Check for hardcoded secrets
          if grep -r "password\|secret\|key\|token" src/ --include="*.rs" | grep -v "test\|example\|config"; then
            echo "::warning::Potential hardcoded secrets found"
          fi

          # Check for unsafe practices
          if grep -r "unwrap()\|expect(" src/ --include="*.rs" | grep -v "test"; then
            echo "::warning::Potential panic-inducing code found"
          fi

          # Check for network operations without proper validation
          if grep -r "TcpStream\|UdpSocket\|Http" src/ --include="*.rs" | grep -v "test"; then
            echo "::notice::Network operations found - ensure proper validation"
          fi

          echo "::endgroup::"

  # ============================================================================
  # SECURITY BASELINE VERIFICATION
  # ============================================================================

  security-baseline:
    name: Security Baseline Check
    runs-on: ubuntu-latest
    # Only run baseline checks during scheduled runs (daily)
    if: github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check security configuration
        run: |
          echo "::group::Security Configuration Audit"

          # Check for essential security configuration files
          SECURITY_FILES=(
            "SECURITY.md"
            ".github/workflows/ci.yml"
            ".github/workflows/deploy.yml"
            ".github/dependabot.yml"
            ".pre-commit-config.yaml"
          )

          for file in "${SECURITY_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "✅ $file exists"
            else
              echo "❌ $file missing"
            fi
          done

          # Check security-related Architecture Decision Records
          echo "\nChecking security-related ADRs:"
          if [ -f "_adrs/0002-webassembly-for-agent-isolation.md" ]; then
            echo "✅ WebAssembly isolation ADR exists"
          else
            echo "❌ WebAssembly isolation ADR missing"
          fi

          if [ -f "_adrs/0003-fipa-messaging-protocol.md" ]; then
            echo "✅ FIPA messaging protocol ADR exists"
          else
            echo "❌ FIPA messaging protocol ADR missing"
          fi

          echo "::endgroup::"

      - name: Generate security dashboard
        run: |
          # Get the current timestamp
          CURRENT_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Count security files present
          SECURITY_FILES_COUNT=0
          for file in "SECURITY.md" ".github/workflows/quality-gate.yml" ".github/dependabot.yml" ".pre-commit-config.yaml" "deny.toml"; do
            if [ -f "$file" ]; then
              SECURITY_FILES_COUNT=$((SECURITY_FILES_COUNT + 1))
            fi
          done

          cat > security-dashboard.md << EOF
          # Security Dashboard

          ## Security Status Report

          **Generated**: $CURRENT_DATE
          **Commit**: \`${{ github.sha }}\`
          **Workflow Run**: #${{ github.run_number }}
          **Trigger**: ${{ github.event_name }}

          ### Security Metrics Summary
          - **Security Configuration Files**: $SECURITY_FILES_COUNT/5 present
          - **Dependency Vulnerabilities**: See detailed audit reports
          - **Code Security Issues**: See CodeQL analysis results

          ### Security Controls Status
          - ✅ Pre-commit hooks configured
          - ✅ Dependabot enabled
          - ✅ Security policy documented
          - ✅ CI/CD security pipeline active
          - ✅ Cargo deny policy enforced
          - ✅ Daily automated security monitoring

          ### Recent Security Activities
          - ✅ Dependency vulnerability audit completed
          - ✅ License compliance check completed
          - ✅ Unsafe code analysis completed
          - ✅ Code security analysis completed
          - ✅ Security configuration baseline verified

          ### Security Recommendations
          1. 🔍 Review any high/critical vulnerabilities immediately
          2. 📦 Update dependencies with security patches promptly
          3. 🔔 Monitor security alerts and GitHub notifications
          4. 📋 Conduct regular manual security reviews
          5. 🧪 Test security controls periodically
          6. 📚 Keep security documentation up to date

          ### Quick Links
          - [Security Policy](../SECURITY.md)
          - [Dependency Policy](../deny.toml)
          - [Quality Gate Workflow](security-monitoring.yml)

          ---
          *🤖 Generated by automated security monitoring pipeline*
          EOF

      - name: Upload security dashboard
        uses: actions/upload-artifact@v4
        with:
          name: security-dashboard-${{ github.run_number }}
          path: security-dashboard.md
          retention-days: 90

  # ============================================================================
  # SECURITY TEAM NOTIFICATION
  # ============================================================================

  notify-security-team:
    name: Notify Security Team
    runs-on: ubuntu-latest
    # Wait for all security jobs to complete before notification
    needs: [dependency-audit, code-security-scan, security-baseline]
    # Always run notification for scheduled scans, regardless of job outcomes
    if: always() && github.event_name == 'schedule'
    permissions:
      issues: write  # Create GitHub issues for security alerts
      contents: read # Read repository contents
    steps:
      - name: Collect security status
        run: |
          echo "::group::Security Monitoring Results"
          echo "Security monitoring completed for run #${{ github.run_number }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Job Results Summary:"
          echo "- Dependency audit: ${{ needs.dependency-audit.result }}"
          echo "- Code security scan: ${{ needs.code-security-scan.result }}"
          echo "- Security baseline: ${{ needs.security-baseline.result }}"
          echo "::endgroup::"

          # Count failures and provide detailed status
          FAILED_JOBS=0
          FAILED_SERVICES=""

          if [ "${{ needs.dependency-audit.result }}" != "success" ]; then
            FAILED_JOBS=$((FAILED_JOBS + 1))
            FAILED_SERVICES="$FAILED_SERVICES dependency-audit"
          fi

          if [ "${{ needs.code-security-scan.result }}" != "success" ]; then
            FAILED_JOBS=$((FAILED_JOBS + 1))
            FAILED_SERVICES="$FAILED_SERVICES code-security-scan"
          fi


          if [ "${{ needs.security-baseline.result }}" != "success" ]; then
            FAILED_JOBS=$((FAILED_JOBS + 1))
            FAILED_SERVICES="$FAILED_SERVICES security-baseline"
          fi

          # Report final status
          if [ $FAILED_JOBS -gt 0 ]; then
            echo "::error::Security monitoring detected $FAILED_JOBS failed job(s): $FAILED_SERVICES"
            echo "::error::Review failed jobs and address security issues before proceeding"
            exit 1
          else
            echo "::notice::✅ All security checks passed successfully"
            echo "::notice::Security posture is good - no immediate action required"
          fi

      - name: Create GitHub issue for failed checks
        if: contains(needs.*.result, 'failure')
        uses: actions/github-script@v7
        with:
          script: |
            const failedJobs = [];
            const jobResults = {
              'dependency-audit': '${{ needs.dependency-audit.result }}',
              'code-security-scan': '${{ needs.code-security-scan.result }}',
              'security-baseline': '${{ needs.security-baseline.result }}'
            };

            for (const [job, result] of Object.entries(jobResults)) {
              if (result === 'failure') {
                failedJobs.push(job);
              }
            }

            if (failedJobs.length === 0) {
              console.log('No failed jobs to report');
              return;
            }

            const issueTitle = `🚨 Security Monitoring Alert - ${failedJobs.length} Failed Check(s)`;
            const issueBody = `
            ## Security Monitoring Failure Alert

            **Alert Generated**: ${new Date().toISOString()}
            **Workflow Run**: [\#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            **Commit**: [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})

            ### Failed Security Checks
            ${failedJobs.map(job => `- ❌ **${job}**: Review logs for specific failures`).join('\n')}

            ### Immediate Actions Required
            1. 🔍 **Review failed job logs** in the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. 🚨 **Address security issues** identified by failed checks
            3. 📊 **Download security reports** from the workflow artifacts
            4. 🔄 **Re-run security checks** after fixes are applied

            ### Security Team Checklist
            - [ ] Reviewed dependency audit failures
            - [ ] Reviewed code security scan failures
            - [ ] Reviewed security baseline failures
            - [ ] Applied necessary fixes or exceptions
            - [ ] Verified fixes with manual testing
            - [ ] Updated security documentation if needed

            ### Workflow Details
            - **Trigger**: ${{ github.event_name }}
            - **Branch**: ${{ github.ref }}
            - **Repository**: ${{ github.repository }}
            - **Run ID**: ${{ github.run_id }}

            ### Next Steps
            1. Address the root cause of each failed check
            2. Update security policies if legitimate exceptions are needed
            3. Close this issue once all security concerns are resolved

            ---
            *🤖 Auto-generated by security monitoring workflow*
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['security', 'urgent', 'automated']
            });
