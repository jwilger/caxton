name: Security Monitoring

# Comprehensive security monitoring workflow for dependency, code, and configuration scanning
# Runs daily automated scans and on changes to security-related files

on:
  schedule:
    # Run daily security checks at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of security scan to run'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - dependencies
          - code
  push:
    branches: [ "main" ]
    paths:
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'deny.toml'
      - '.github/workflows/security-monitoring.yml'
  pull_request:
    branches: [ "main" ]
    paths:
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'deny.toml'
      - '.github/workflows/security-monitoring.yml'

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: 1

# Global environment variables for consistent security scanning behavior

permissions:
  contents: read
  security-events: write
  actions: read
  issues: write

# Required permissions for security scanning and issue creation

jobs:
  # ============================================================================
  # DEPENDENCY SECURITY SCANNING
  # ============================================================================
  dependency-audit:
    name: Daily Dependency Audit
    runs-on: ubuntu-latest
    # Run for full scans, dependency-only scans, or scheduled daily runs
    if: github.event.inputs.scan_type == 'full' || github.event.inputs.scan_type == 'dependencies' || github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Install security tools
        run: |
          # Install security auditing tools with locked versions for reproducibility
          cargo install --locked cargo-audit cargo-deny

          echo "Tool versions:"
          cargo audit --version
          cargo deny --version

      - name: Run comprehensive security audit
        run: |
          echo "::group::Vulnerability Audit"
          set +e  # Don't exit on error immediately to allow proper error handling

          # Run audit and capture exit code
          cargo audit --json > audit-report.json
          AUDIT_EXIT_CODE=$?

          # Ensure valid JSON output even on error
          if [ ! -s audit-report.json ] || ! jq empty audit-report.json 2>/dev/null; then
            echo '{"vulnerabilities": [], "warnings": []}' > audit-report.json
          fi

          # Check if vulnerabilities found
          VULN_COUNT=$(jq '.vulnerabilities | length' audit-report.json 2>/dev/null || echo 0)
          WARNING_COUNT=$(jq '.warnings | length' audit-report.json 2>/dev/null || echo 0)

          echo "Vulnerabilities found: $VULN_COUNT"
          echo "Warnings found: $WARNING_COUNT"

          if [ "$VULN_COUNT" -gt 0 ]; then
            echo "::error::$VULN_COUNT vulnerabilities found"
            jq -r '.vulnerabilities[] | "ID: \(.id), Package: \(.package.name), Severity: \(.advisory.severity // "unknown")"' audit-report.json
            exit 1
          elif [ "$WARNING_COUNT" -gt 0 ]; then
            echo "::warning::$WARNING_COUNT warnings found"
            jq -r '.warnings[] | "Kind: \(.kind), Message: \(.message)"' audit-report.json
          else
            echo "::notice::No vulnerabilities or warnings found"
          fi
          echo "::endgroup::"

          # Exit with original audit exit code if there were vulnerabilities
          if [ "$VULN_COUNT" -gt 0 ]; then
            exit $AUDIT_EXIT_CODE
          fi

      - name: Run cargo-deny check
        run: |
          echo "::group::Cargo Deny Check"
          # Run cargo deny check with proper exit code handling
          set +e  # Don't exit on error immediately
          cargo deny check --format json > deny-results.json
          DENY_EXIT_CODE=$?
          set -e  # Re-enable exit on error

          # Only suppress policy violation errors (exit code 1)
          # Fail on tool/configuration errors (other exit codes)
          if [ $DENY_EXIT_CODE -ne 0 ] && [ $DENY_EXIT_CODE -ne 1 ]; then
            echo "::error::cargo deny tool failed with exit code $DENY_EXIT_CODE"
            echo "::error::This indicates a configuration or tool error, not policy violations"
            exit $DENY_EXIT_CODE
          fi

          # Enhanced error reporting while maintaining test compatibility
          if [ -s deny-results.json ]; then
            # Check for errors in different categories
            LICENSE_ERRORS=$(jq '.errors[]? | select(.type == "license") | length' deny-results.json 2>/dev/null || echo 0)
            ADVISORY_ERRORS=$(jq '.errors[]? | select(.type == "advisory") | length' deny-results.json 2>/dev/null || echo 0)
            BAN_ERRORS=$(jq '.errors[]? | select(.type == "ban") | length' deny-results.json 2>/dev/null || echo 0)
            SOURCE_ERRORS=$(jq '.errors[]? | select(.type == "source") | length' deny-results.json 2>/dev/null || echo 0)

            TOTAL_ERRORS=$((LICENSE_ERRORS + ADVISORY_ERRORS + BAN_ERRORS + SOURCE_ERRORS))

            if [ "$TOTAL_ERRORS" -gt 0 ]; then
              echo "::error::$TOTAL_ERRORS deny violations found"
              jq -r '.errors[]? | "\(.type | upper): \(.message)"' deny-results.json || true
              exit 1
            else
              echo "::notice::No deny violations found"
            fi
          else
            echo "::notice::No deny violations found"
          fi
          echo "::endgroup::"

      - name: Analyze dependency tree
        run: |
          echo "::group::Dependency Analysis"
          cargo tree --format "{p} {r}" > dependency-tree.txt

          # Count dependencies
          DIRECT_DEPS=$(grep -v "â”œâ”€\|â””â”€" dependency-tree.txt | wc -l)
          TOTAL_DEPS=$(wc -l < dependency-tree.txt)

          echo "Direct dependencies: $DIRECT_DEPS"
          echo "Total dependencies: $TOTAL_DEPS"

          # Check for security-sensitive dependencies
          echo "Security-sensitive dependencies:"
          grep -E "(crypto|ssl|tls|auth|rand|hash)" dependency-tree.txt || echo "None found"
          echo "::endgroup::"

      - name: Check for unsafe code
        run: |
          echo "::group::Unsafe Code Analysis"
          # Install cargo-geiger separately to avoid conflicts
          cargo install --locked cargo-geiger || echo "::warning::cargo-geiger installation failed, skipping unsafe code analysis"

          if command -v cargo-geiger &> /dev/null; then
            cargo geiger --format json > geiger-report.json || echo '{}' > geiger-report.json

            if [ -s geiger-report.json ] && [ "$(cat geiger-report.json)" != "{}" ]; then
              UNSAFE_COUNT=$(jq '.used.functions.unsafe + .used.expressions.unsafe + .used.impls.unsafe + .used.traits.unsafe + .used.methods.unsafe' geiger-report.json 2>/dev/null || echo 0)

              if [ "$UNSAFE_COUNT" -gt 0 ]; then
                echo "::warning::$UNSAFE_COUNT unsafe code blocks found"
                cargo geiger || true
              else
                echo "::notice::No unsafe code found"
              fi
            else
              echo "::warning::cargo-geiger analysis could not be completed"
            fi
          else
            echo "::warning::cargo-geiger not available, skipping unsafe code analysis"
            echo '{}' > geiger-report.json
          fi
          echo "::endgroup::"

      - name: Generate security summary
        if: always()
        run: |
          echo "::group::Security Summary"

          # Create a summary report
          cat > security-summary.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "vulnerabilities": $(jq '.vulnerabilities | length' audit-report.json 2>/dev/null || echo 0),
            "warnings": $(jq '.warnings | length' audit-report.json 2>/dev/null || echo 0),
            "deny_violations": {
              "total": $(jq '.errors | length' deny-results.json 2>/dev/null || echo 0)
            },
            "unsafe_code_blocks": $(jq '.used.functions.unsafe + .used.expressions.unsafe + .used.impls.unsafe + .used.traits.unsafe + .used.methods.unsafe' geiger-report.json 2>/dev/null || echo 0)
          }
          EOF

          echo "Security scan summary:"
          jq . security-summary.json
          echo "::endgroup::"

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports-${{ github.run_number }}
          path: |
            audit-report.json
            deny-results.json
            dependency-tree.txt
            geiger-report.json
            security-summary.json
          retention-days: 30

  # ============================================================================
  # CODE SECURITY SCANNING
  # ============================================================================

  code-security-scan:
    name: Code Security Scan
    runs-on: ubuntu-latest
    # Run for full scans, code-only scans, or scheduled daily runs
    if: github.event.inputs.scan_type == 'full' || github.event.inputs.scan_type == 'code' || github.event_name == 'schedule'
    permissions:
      contents: read
      security-events: write
      actions: read
    env:
      # Enable experimental CodeQL features for enhanced Rust analysis
      CODEQL_ENABLE_EXPERIMENTAL_FEATURES: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Initialize CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: rust
          config-file: ./.github/codeql/codeql-config.yml

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@v1

      - name: Build for CodeQL Analysis
        run: |
          # Build all workspace targets to ensure comprehensive analysis coverage
          cargo build --workspace --all-targets

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      - name: Check for security patterns
        run: |
          echo "::group::Security Pattern Analysis"

          # Check for hardcoded secrets
          if grep -r "password\|secret\|key\|token" src/ --include="*.rs" | grep -v "test\|example\|config"; then
            echo "::warning::Potential hardcoded secrets found"
          fi

          # Check for unsafe practices
          if grep -r "unwrap()\|expect(" src/ --include="*.rs" | grep -v "test"; then
            echo "::warning::Potential panic-inducing code found"
          fi

          # Check for network operations without proper validation
          if grep -r "TcpStream\|UdpSocket\|Http" src/ --include="*.rs" | grep -v "test"; then
            echo "::notice::Network operations found - ensure proper validation"
          fi

          echo "::endgroup::"

  # ============================================================================
  # SECURITY BASELINE VERIFICATION
  # ============================================================================

  security-baseline:
    name: Security Baseline Check
    runs-on: ubuntu-latest
    # Only run baseline checks during scheduled runs (daily)
    if: github.event_name == 'schedule'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check security configuration
        run: |
          echo "::group::Security Configuration Audit"

          # Check for essential security configuration files
          SECURITY_FILES=(
            "SECURITY.md"
            ".github/workflows/ci.yml"
            ".github/workflows/deploy.yml"
            ".github/dependabot.yml"
            ".pre-commit-config.yaml"
          )

          for file in "${SECURITY_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "âœ… $file exists"
            else
              echo "âŒ $file missing"
            fi
          done

          # Check security-related Architecture Decision Records
          echo "\nChecking security-related ADRs:"
          if [ -f "_adrs/0002-webassembly-for-agent-isolation.md" ]; then
            echo "âœ… WebAssembly isolation ADR exists"
          else
            echo "âŒ WebAssembly isolation ADR missing"
          fi

          if [ -f "_adrs/0003-fipa-messaging-protocol.md" ]; then
            echo "âœ… FIPA messaging protocol ADR exists"
          else
            echo "âŒ FIPA messaging protocol ADR missing"
          fi

          echo "::endgroup::"

      - name: Generate security dashboard
        run: |
          # Get the current timestamp
          CURRENT_DATE=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Count security files present
          SECURITY_FILES_COUNT=0
          for file in "SECURITY.md" ".github/workflows/quality-gate.yml" ".github/dependabot.yml" ".pre-commit-config.yaml" "deny.toml"; do
            if [ -f "$file" ]; then
              SECURITY_FILES_COUNT=$((SECURITY_FILES_COUNT + 1))
            fi
          done

          cat > security-dashboard.md << EOF
          # Security Dashboard

          ## Security Status Report

          **Generated**: $CURRENT_DATE
          **Commit**: \`${{ github.sha }}\`
          **Workflow Run**: #${{ github.run_number }}
          **Trigger**: ${{ github.event_name }}

          ### Security Metrics Summary
          - **Security Configuration Files**: $SECURITY_FILES_COUNT/5 present
          - **Dependency Vulnerabilities**: See detailed audit reports
          - **Code Security Issues**: See CodeQL analysis results

          ### Security Controls Status
          - âœ… Pre-commit hooks configured
          - âœ… Dependabot enabled
          - âœ… Security policy documented
          - âœ… CI/CD security pipeline active
          - âœ… Cargo deny policy enforced
          - âœ… Daily automated security monitoring

          ### Recent Security Activities
          - âœ… Dependency vulnerability audit completed
          - âœ… License compliance check completed
          - âœ… Unsafe code analysis completed
          - âœ… Code security analysis completed
          - âœ… Security configuration baseline verified

          ### Security Recommendations
          1. ğŸ” Review any high/critical vulnerabilities immediately
          2. ğŸ“¦ Update dependencies with security patches promptly
          3. ğŸ”” Monitor security alerts and GitHub notifications
          4. ğŸ“‹ Conduct regular manual security reviews
          5. ğŸ§ª Test security controls periodically
          6. ğŸ“š Keep security documentation up to date

          ### Quick Links
          - [Security Policy](../SECURITY.md)
          - [Dependency Policy](../deny.toml)
          - [Quality Gate Workflow](security-monitoring.yml)

          ---
          *ğŸ¤– Generated by automated security monitoring pipeline*
          EOF

      - name: Upload security dashboard
        uses: actions/upload-artifact@v4
        with:
          name: security-dashboard-${{ github.run_number }}
          path: security-dashboard.md
          retention-days: 90

  # ============================================================================
  # SECURITY TEAM NOTIFICATION
  # ============================================================================

  notify-security-team:
    name: Notify Security Team
    runs-on: ubuntu-latest
    # Wait for all security jobs to complete before notification
    needs: [dependency-audit, code-security-scan, security-baseline]
    # Always run notification for scheduled scans, regardless of job outcomes
    if: always() && github.event_name == 'schedule'
    permissions:
      issues: write  # Create GitHub issues for security alerts
      contents: read # Read repository contents
    steps:
      - name: Collect security status
        run: |
          echo "::group::Security Monitoring Results"
          echo "Security monitoring completed for run #${{ github.run_number }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Job Results Summary:"
          echo "- Dependency audit: ${{ needs.dependency-audit.result }}"
          echo "- Code security scan: ${{ needs.code-security-scan.result }}"
          echo "- Security baseline: ${{ needs.security-baseline.result }}"
          echo "::endgroup::"

          # Count failures and provide detailed status
          FAILED_JOBS=0
          FAILED_SERVICES=""

          if [ "${{ needs.dependency-audit.result }}" != "success" ]; then
            FAILED_JOBS=$((FAILED_JOBS + 1))
            FAILED_SERVICES="$FAILED_SERVICES dependency-audit"
          fi

          if [ "${{ needs.code-security-scan.result }}" != "success" ]; then
            FAILED_JOBS=$((FAILED_JOBS + 1))
            FAILED_SERVICES="$FAILED_SERVICES code-security-scan"
          fi


          if [ "${{ needs.security-baseline.result }}" != "success" ]; then
            FAILED_JOBS=$((FAILED_JOBS + 1))
            FAILED_SERVICES="$FAILED_SERVICES security-baseline"
          fi

          # Report final status
          if [ $FAILED_JOBS -gt 0 ]; then
            echo "::error::Security monitoring detected $FAILED_JOBS failed job(s): $FAILED_SERVICES"
            echo "::error::Review failed jobs and address security issues before proceeding"
            exit 1
          else
            echo "::notice::âœ… All security checks passed successfully"
            echo "::notice::Security posture is good - no immediate action required"
          fi

      - name: Create GitHub issue for failed checks
        if: contains(needs.*.result, 'failure')
        uses: actions/github-script@v7
        with:
          script: |
            const failedJobs = [];
            const jobResults = {
              'dependency-audit': '${{ needs.dependency-audit.result }}',
              'code-security-scan': '${{ needs.code-security-scan.result }}',
              'security-baseline': '${{ needs.security-baseline.result }}'
            };

            for (const [job, result] of Object.entries(jobResults)) {
              if (result === 'failure') {
                failedJobs.push(job);
              }
            }

            if (failedJobs.length === 0) {
              console.log('No failed jobs to report');
              return;
            }

            const issueTitle = `ğŸš¨ Security Monitoring Alert - ${failedJobs.length} Failed Check(s)`;
            const issueBody = `
            ## Security Monitoring Failure Alert

            **Alert Generated**: ${new Date().toISOString()}
            **Workflow Run**: [\#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            **Commit**: [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})

            ### Failed Security Checks
            ${failedJobs.map(job => `- âŒ **${job}**: Review logs for specific failures`).join('\n')}

            ### Immediate Actions Required
            1. ğŸ” **Review failed job logs** in the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. ğŸš¨ **Address security issues** identified by failed checks
            3. ğŸ“Š **Download security reports** from the workflow artifacts
            4. ğŸ”„ **Re-run security checks** after fixes are applied

            ### Security Team Checklist
            - [ ] Reviewed dependency audit failures
            - [ ] Reviewed code security scan failures
            - [ ] Reviewed security baseline failures
            - [ ] Applied necessary fixes or exceptions
            - [ ] Verified fixes with manual testing
            - [ ] Updated security documentation if needed

            ### Workflow Details
            - **Trigger**: ${{ github.event_name }}
            - **Branch**: ${{ github.ref }}
            - **Repository**: ${{ github.repository }}
            - **Run ID**: ${{ github.run_id }}

            ### Next Steps
            1. Address the root cause of each failed check
            2. Update security policies if legitimate exceptions are needed
            3. Close this issue once all security concerns are resolved

            ---
            *ğŸ¤– Auto-generated by security monitoring workflow*
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['security', 'urgent', 'automated']
            });
