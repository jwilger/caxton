#!/bin/bash
# memory-cli - Command-line interface for agent memory system
set -euo pipefail

# Source libraries
SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
source "$SCRIPT_DIR/memory-cli-config.sh"
source "$SCRIPT_DIR/memory-cli-lib.sh"

# Version
VERSION="1.0.0"

# Usage information
show_usage() {
    cat <<EOF
Memory CLI v$VERSION - Agent memory management system

USAGE:
    memory-cli <command> [options]

COMMANDS:
    save        Save a new memory
    search      Search existing memories
    list        List memories by criteria
    update      Update existing memory
    delete      Delete a memory
    rebuild-index Rebuild index files from existing memories
    help        Show this help

SAVE COMMAND:
    memory-cli save --agent <name> --scope <private|shared> --title <text>
                    --content <text> [--tags <tag1,tag2>] [--category <type>]
                    [--priority <low|medium|high>] [--story <context>]

SEARCH COMMAND:
    memory-cli search --query <text> [--scope <all|private|shared>]
                      [--agent <name>] [--tags <tag1,tag2>] [--limit <n>]

LIST COMMAND:
    memory-cli list [--scope <all|private|shared>] [--agent <name>]
                    [--category <type>] [--limit <n>]

UPDATE COMMAND:
    memory-cli update --id <memory-id> --agent <name> [--title <text>]
                      [--content <text>] [--tags <tag1,tag2>] [--category <type>]

DELETE COMMAND:
    memory-cli delete --id <memory-id> --agent <name>

REBUILD-INDEX COMMAND:
    memory-cli rebuild-index [--scope <private|shared|all>]

OPTIONS:
    --agent         Agent name (required for save/update/delete)
    --scope         Memory scope: private, shared, or all (default: all for search/list)
    --title         Memory title (required for save)
    --content       Memory content (required for save)
    --tags          Comma-separated tags
    --category      Memory category: decisions, learnings, context, general (default: general)
    --priority      Priority level: low, medium, high (default: low)
    --story         Story context for the memory
    --query         Search query text
    --id            Memory ID for update/delete operations
    --limit         Maximum results to return (default: 10, max: 100)
    --debug         Enable debug logging
    --version       Show version
    --help, -h      Show help

EXAMPLES:
    # Save a new decision
    memory-cli save --agent implementer --scope shared --category decisions \\
                    --title "Use nutype for domain types" \\
                    --content "Decided to use nutype crate to eliminate primitive obsession" \\
                    --tags "types,nutype,domain-modeling"

    # Search for TDD-related memories
    memory-cli search --query "test" --tags "tdd" --limit 5

    # List recent private memories for specific agent
    memory-cli list --scope private --agent planner --limit 10

    # Update a memory's content
    memory-cli update --id 1723402500-type-architect-decisions-a7b2c9 --agent type-architect \\
                      --content "Updated decision on nutype usage"

    # Delete a memory
    memory-cli delete --id 1723402500-type-architect-decisions-a7b2c9 --agent type-architect

    # Rebuild index files from existing memories
    memory-cli rebuild-index --scope shared

    # Rebuild all index files
    memory-cli rebuild-index --scope all

ENVIRONMENT:
    DEBUG=1         Enable debug output
    MEMORY_CLI_CONFIG Override config file path
EOF
}

# Parse command line arguments
parse_args() {
    COMMAND=""
    AGENT=""
    SCOPE=""
    TITLE=""
    CONTENT=""
    TAGS=""
    CATEGORY=""
    PRIORITY="low"
    STORY_CONTEXT=""
    QUERY=""
    MEMORY_ID=""
    LIMIT="$DEFAULT_SEARCH_LIMIT"

    while [[ $# -gt 0 ]]; do
        case $1 in
            save|search|list|update|delete|rebuild-index|help)
                COMMAND="$1"
                shift
                ;;
            --agent)
                AGENT="$2"
                shift 2
                ;;
            --scope)
                SCOPE="$2"
                shift 2
                ;;
            --title)
                TITLE="$2"
                shift 2
                ;;
            --content)
                CONTENT="$2"
                shift 2
                ;;
            --tags)
                TAGS="$2"
                shift 2
                ;;
            --category)
                CATEGORY="$2"
                shift 2
                ;;
            --priority)
                PRIORITY="$2"
                shift 2
                ;;
            --story)
                STORY_CONTEXT="$2"
                shift 2
                ;;
            --query)
                QUERY="$2"
                shift 2
                ;;
            --id)
                MEMORY_ID="$2"
                shift 2
                ;;
            --limit)
                LIMIT="$2"
                shift 2
                ;;
            --debug)
                DEBUG=1
                shift
                ;;
            --version)
                echo "memory-cli version $VERSION"
                exit 0
                ;;
            --help|-h|help)
                show_usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage >&2
                exit 1
                ;;
        esac
    done

    if [[ -z "$COMMAND" ]]; then
        log_error "Command required"
        show_usage >&2
        exit 1
    fi
}

# Validate arguments for specific commands
validate_args() {
    case "$COMMAND" in
        save)
            if [[ -z "$AGENT" || -z "$SCOPE" || -z "$TITLE" || -z "$CONTENT" ]]; then
                log_error "Save command requires: --agent, --scope, --title, --content"
                exit 1
            fi

            # Set default category if not provided
            if [[ -z "$CATEGORY" ]]; then
                CATEGORY="general"
            fi

            if ! is_valid_agent "$AGENT"; then
                log_error "Invalid agent: $AGENT. Valid agents: ${VALID_AGENTS[*]}"
                exit 1
            fi

            if ! is_valid_scope "$SCOPE"; then
                log_error "Invalid scope: $SCOPE. Valid scopes: ${VALID_SCOPES[*]}"
                exit 1
            fi

            if ! is_valid_category "$CATEGORY"; then
                log_error "Invalid category: $CATEGORY. Valid categories: ${VALID_CATEGORIES[*]}"
                exit 1
            fi

            if ! is_valid_priority "$PRIORITY"; then
                log_error "Invalid priority: $PRIORITY. Valid priorities: ${VALID_PRIORITIES[*]}"
                exit 1
            fi
            ;;
        search)
            if [[ -n "$SCOPE" ]]; then
                if [[ "$SCOPE" != "all" && "$SCOPE" != "private" && "$SCOPE" != "shared" ]]; then
                    log_error "Invalid scope for search: $SCOPE. Valid: all, private, shared"
                    exit 1
                fi
            fi

            if [[ -n "$AGENT" ]]; then
                if ! is_valid_agent "$AGENT"; then
                    log_error "Invalid agent: $AGENT. Valid agents: ${VALID_AGENTS[*]}"
                    exit 1
                fi
            fi

            if [[ -n "$LIMIT" && "$LIMIT" -gt "$MAX_SEARCH_LIMIT" ]]; then
                log_error "Limit exceeds maximum: $LIMIT > $MAX_SEARCH_LIMIT"
                exit 1
            fi
            ;;
        list)
            if [[ -n "$SCOPE" ]]; then
                if [[ "$SCOPE" != "all" && "$SCOPE" != "private" && "$SCOPE" != "shared" ]]; then
                    log_error "Invalid scope for list: $SCOPE. Valid: all, private, shared"
                    exit 1
                fi
            fi

            if [[ -n "$AGENT" ]]; then
                if ! is_valid_agent "$AGENT"; then
                    log_error "Invalid agent: $AGENT. Valid agents: ${VALID_AGENTS[*]}"
                    exit 1
                fi
            fi

            if [[ -n "$CATEGORY" ]]; then
                if ! is_valid_category "$CATEGORY"; then
                    log_error "Invalid category: $CATEGORY. Valid categories: ${VALID_CATEGORIES[*]}"
                    exit 1
                fi
            fi
            ;;
        update)
            if [[ -z "$MEMORY_ID" || -z "$AGENT" ]]; then
                log_error "Update command requires: --id, --agent"
                exit 1
            fi

            if ! is_valid_agent "$AGENT"; then
                log_error "Invalid agent: $AGENT. Valid agents: ${VALID_AGENTS[*]}"
                exit 1
            fi
            ;;
        delete)
            if [[ -z "$MEMORY_ID" || -z "$AGENT" ]]; then
                log_error "Delete command requires: --id, --agent"
                exit 1
            fi

            if ! is_valid_agent "$AGENT"; then
                log_error "Invalid agent: $AGENT. Valid agents: ${VALID_AGENTS[*]}"
                exit 1
            fi
            ;;
        rebuild-index)
            if [[ -n "$SCOPE" ]]; then
                if [[ "$SCOPE" != "all" && "$SCOPE" != "private" && "$SCOPE" != "shared" ]]; then
                    log_error "Invalid scope for rebuild-index: $SCOPE. Valid: all, private, shared"
                    exit 1
                fi
            fi
            ;;
    esac
}

# Save command implementation
cmd_save() {
    log_debug "Saving memory: agent=$AGENT, scope=$SCOPE, category=$CATEGORY"

    # Generate memory JSON
    local memory_json
    memory_json=$(generate_memory_json "$AGENT" "$SCOPE" "$CATEGORY" "$TITLE" "$CONTENT" "$TAGS" "$STORY_CONTEXT" "$PRIORITY")

    # Validate generated JSON
    if ! validate_memory_json "$memory_json"; then
        log_error "Generated invalid memory JSON"
        exit 1
    fi

    # Get memory ID and file path
    local memory_id
    memory_id=$(echo "$memory_json" | jq -r '.id')
    local memory_path
    memory_path=$(get_memory_path "$SCOPE" "$AGENT" "$CATEGORY" "$memory_id")

    # Ensure directory exists
    ensure_directory "$(dirname "$memory_path")"

    # Save memory file
    if atomic_write "$memory_path" "$memory_json"; then
        log_info "Memory saved: $memory_id"
        echo "$memory_id"

        # Update indices
        if ! update_indices "$memory_path" "add"; then
            log_error "Warning: Failed to update indices"
        fi
    else
        log_error "Failed to save memory"
        exit 1
    fi
}

# Search command implementation
cmd_search() {
    log_debug "Searching memories: query='$QUERY', scope=$SCOPE, agent=$AGENT, tags=$TAGS"

    # Default scope to 'all' if not specified
    local search_scope="${SCOPE:-all}"

    # Search memories
    local results
    results=$(search_memories "$QUERY" "$search_scope" "$AGENT" "$TAGS" "$LIMIT")

    if [[ -z "$results" ]]; then
        log_info "No memories found"
        return 0
    fi

    # Display results
    echo "Found memories:"
    echo "$results" | while IFS= read -r file; do
        if [[ -f "$file" ]]; then
            local memory_json
            memory_json=$(cat "$file")
            local id title agent created_at
            id=$(echo "$memory_json" | jq -r '.id')
            title=$(echo "$memory_json" | jq -r '.title')
            agent=$(echo "$memory_json" | jq -r '.agent')
            created_at=$(echo "$memory_json" | jq -r '.metadata.created_at')

            echo "  $id | $agent | $title | $created_at"
        fi
    done
}

# List command implementation
cmd_list() {
    log_debug "Listing memories: scope=$SCOPE, agent=$AGENT, category=$CATEGORY"

    local search_scope="${SCOPE:-all}"

    # Build filter criteria
    local category_filter=""
    if [[ -n "$CATEGORY" ]]; then
        category_filter="$CATEGORY"
    fi

    # Use search with empty query to list all
    local results
    results=$(search_memories "" "$search_scope" "$AGENT" "" "$LIMIT")

    if [[ -z "$results" ]]; then
        log_info "No memories found"
        return 0
    fi

    # Filter by category if specified
    if [[ -n "$category_filter" ]]; then
        local filtered_results=$(mktemp)
        echo "$results" | while IFS= read -r file; do
            if [[ -f "$file" ]]; then
                if jq -e ".category == \"$category_filter\"" "$file" >/dev/null 2>&1; then
                    echo "$file" >> "$filtered_results"
                fi
            fi
        done
        results=$(cat "$filtered_results")
        rm -f "$filtered_results"
    fi

    # Display results
    echo "Memory list:"
    echo "$results" | while IFS= read -r file; do
        if [[ -f "$file" ]]; then
            local memory_json
            memory_json=$(cat "$file")
            local id title agent category scope created_at
            id=$(echo "$memory_json" | jq -r '.id')
            title=$(echo "$memory_json" | jq -r '.title')
            agent=$(echo "$memory_json" | jq -r '.agent')
            category=$(echo "$memory_json" | jq -r '.category')
            scope=$(echo "$memory_json" | jq -r '.scope')
            created_at=$(echo "$memory_json" | jq -r '.metadata.created_at')

            echo "  $id | $agent | $scope | $category | $title | $created_at"
        fi
    done
}

# Update command implementation
cmd_update() {
    log_debug "Updating memory: id=$MEMORY_ID, agent=$AGENT"

    # Find existing memory
    local memory_file
    memory_file=$(find_memory_by_id "$MEMORY_ID" "$AGENT")

    if [[ -z "$memory_file" || ! -f "$memory_file" ]]; then
        log_error "Memory not found: $MEMORY_ID"
        exit 1
    fi

    # Read existing memory
    local existing_json
    existing_json=$(cat "$memory_file")

    # Verify ownership
    local existing_agent
    existing_agent=$(echo "$existing_json" | jq -r '.agent')
    if [[ "$existing_agent" != "$AGENT" ]]; then
        log_error "Permission denied: memory belongs to $existing_agent, not $AGENT"
        exit 1
    fi

    # Update fields if provided
    local updated_json="$existing_json"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    if [[ -n "$TITLE" ]]; then
        updated_json=$(echo "$updated_json" | jq --arg title "$TITLE" '.title = $title')
    fi

    if [[ -n "$CONTENT" ]]; then
        updated_json=$(echo "$updated_json" | jq --arg content "$CONTENT" '.content = $content')
    fi

    if [[ -n "$TAGS" ]]; then
        # Convert comma-separated tags to JSON array
        IFS=',' read -ra tag_array <<< "$TAGS"
        local tag_list=""
        for tag in "${tag_array[@]}"; do
            tag=$(echo "$tag" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            if [[ -n "$tag" ]]; then
                tag_list="$tag_list\"$tag\","
            fi
        done
        if [[ -n "$tag_list" ]]; then
            tag_list="${tag_list%,}"
            local tags_json="[$tag_list]"
            updated_json=$(echo "$updated_json" | jq --argjson tags "$tags_json" '.tags = $tags')
        fi
    fi

    if [[ -n "$CATEGORY" ]]; then
        if ! is_valid_category "$CATEGORY"; then
            log_error "Invalid category: $CATEGORY"
            exit 1
        fi
        updated_json=$(echo "$updated_json" | jq --arg category "$CATEGORY" '.category = $category')
    fi

    # Update metadata
    updated_json=$(echo "$updated_json" | jq --arg timestamp "$timestamp" '.metadata.updated_at = $timestamp')

    # Validate updated JSON
    if ! validate_memory_json "$updated_json"; then
        log_error "Updated memory JSON is invalid"
        exit 1
    fi

    # Atomic write
    if atomic_write "$memory_file" "$updated_json"; then
        log_info "Memory updated: $MEMORY_ID"

        # Update indices
        if ! update_indices "$memory_file" "update"; then
            log_error "Warning: Failed to update indices"
        fi
    else
        log_error "Failed to update memory"
        exit 1
    fi
}

# Delete command implementation
cmd_delete() {
    log_debug "Deleting memory: id=$MEMORY_ID, agent=$AGENT"

    # Find existing memory
    local memory_file
    memory_file=$(find_memory_by_id "$MEMORY_ID" "$AGENT")

    if [[ -z "$memory_file" || ! -f "$memory_file" ]]; then
        log_error "Memory not found: $MEMORY_ID"
        exit 1
    fi

    # Verify ownership
    local existing_json
    existing_json=$(cat "$memory_file")
    local existing_agent
    existing_agent=$(echo "$existing_json" | jq -r '.agent')
    if [[ "$existing_agent" != "$AGENT" ]]; then
        log_error "Permission denied: memory belongs to $existing_agent, not $AGENT"
        exit 1
    fi

    # Update indices before deletion
    if ! update_indices "$memory_file" "delete"; then
        log_error "Warning: Failed to update indices"
    fi

    # Delete file
    if rm "$memory_file"; then
        log_info "Memory deleted: $MEMORY_ID"
    else
        log_error "Failed to delete memory file"
        exit 1
    fi
}

# Rebuild index command implementation
cmd_rebuild_index() {
    local rebuild_scope="${SCOPE:-all}"
    log_debug "Rebuilding index: scope=$rebuild_scope"

    local scopes_to_rebuild=()
    if [[ "$rebuild_scope" == "all" ]]; then
        scopes_to_rebuild=("shared" "private")
    else
        scopes_to_rebuild=("$rebuild_scope")
    fi

    for scope in "${scopes_to_rebuild[@]}"; do
        log_info "Rebuilding $scope index..."

        if ! rebuild_index_for_scope "$scope"; then
            log_error "Failed to rebuild $scope index"
            exit 1
        fi

        log_info "Successfully rebuilt $scope index"
    done

    log_info "Index rebuild complete"
}

# Main execution
main() {
    # Check required tools
    if ! check_required_tools; then
        exit 1
    fi

    # Parse arguments
    parse_args "$@"

    # Validate arguments
    validate_args

    # Execute command
    case "$COMMAND" in
        save)
            cmd_save
            ;;
        search)
            cmd_search
            ;;
        list)
            cmd_list
            ;;
        update)
            cmd_update
            ;;
        delete)
            cmd_delete
            ;;
        rebuild-index)
            cmd_rebuild_index
            ;;
        help)
            show_usage
            ;;
        *)
            log_error "Unknown command: $COMMAND"
            show_usage >&2
            exit 1
            ;;
    esac
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
